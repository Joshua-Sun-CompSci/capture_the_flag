import Text.Read (readMaybe) -- used in parseMove, a function generated by ChatGPT
----------------------------------------------------------------------------
---                            initialization                            ---
----------------------------------------------------------------------------
-- name important variables here for clarity. Otherwise leaving String, [String] and Char everywhere will be a disaster
type Board = [Char]
type Board2D = [[Char]]
-- note: This assumes white always start on top, and black always start on the bottom (which it should be),
-- so white pawns can move DOWNWARDS and black pawns can move UPWARDS
type Player = Char -- this represents the player the computer is playing; it is always either 'b' or 'w'
type History = [Board]

-- this function initializes a n*n board, where n is the input
-- it expects an integer representing the dimension of the board, then returns a n*n board filled with '-'
initBoard :: Int -> Board
initBoard n = replicate (n * n) '-'  -- creates a board filled with -
---------------------------------------------------------------------------
---                            visualization                            ---
---------------------------------------------------------------------------
-- this function visualizes the board
-- it takes a board as an argument and prints out the board in 2D format
visualizeBoard :: Board -> IO ()
visualizeBoard board = 
    let board2D = make2DBoard board
    in printBoard board2D

-- this function converts a board from 1D to 2D
-- it takes a board as an argument and return a 2D list of char, each char represent a segment on the board
make2DBoard :: Board -> Board2D
make2DBoard board =
        let n = getBoardDim board
        in make2DBoardHelper board n

-- this is the helper function of make2D board
-- it takes 2 parameters, a board and a number(n), with n representing the board dimension
-- the reason we need a helper function here is because without it, the dimension changes every time,
-- making the 2D list incorrect (i.e. it would've become ["-wWw-","-www","----","---","bbb","--","bB","b","-"]
-- instead of ["-wWw-","-www-","-----","-bbb-","-bBb-"])
make2DBoardHelper :: Board -> Int -> Board2D
make2DBoardHelper boardString n
    -- base case; if board is empty, return the 2d list
    | null boardString = []
    -- if board is not empty, take the next row and store it as [Char]
    | otherwise = take n boardString : make2DBoardHelper (drop n boardString) n

-- this function prints out the 2D board
-- it takes a 2D board as an argument and prints it out line by line
printBoard :: Board2D -> IO ()
printBoard board2D
    -- base case; when everything is print out, return and finish function
    | null board2D = return()
    -- if board2D is not empty, print out the first line, and recursively print out the rest of the lines
    | otherwise = do
        putStrLn (head board2D) -- this prints the first [Char]
        printBoard (tail board2D)

-----------------------------------------------------------------------------
---                            move generation                            ---
-----------------------------------------------------------------------------
-- copied from slides and edited, this generates all possible next move
-- it takes a board and the player that will make the next move as arguments
-- and return a list of all possible boards a move can create
generateNewStates :: Board -> Player -> [Board]
generateNewStates board player =
    concat [generatePawnMove board player, 
            generateFlagMove board player]

-- this generates all possible pawn moves
-- it takes a board and the player that will make the next move as arguments
-- and return a list of all possible boards by moving a PAWN
generatePawnMove :: Board -> Player -> [Board]
generatePawnMove board player =
    concat [generatePawnMoveSideways board player, 
            generatePawnMoveForward board player,
            generatePawnJumpSideways board player,
            generatePawnJumpForward board player]

-- this generates all possible flag moves
-- it takes a board and the player that will make the next move as arguments
-- and return a list of all possible boards by moving a FLAG
generateFlagMove :: Board -> Player -> [Board]
generateFlagMove board player =
    concat [generateFlagMoveSideways board player, 
            generateFlagMoveBackAndForth board player]

-- this generates all possible sideway pawn moves
-- it takes a board and the player that will make the next move as arguments
-- and returns a list of all possible boards by moving a PAWN sideways
generatePawnMoveSideways :: Board -> Player -> [Board]
generatePawnMoveSideways board player = 
    concat [generateNewRowBounded board 0 ([player] ++ "-") ("-" ++ [player]) (getBoardDim board),
            generateNewRowBounded board 0 ("-" ++ [player]) ([player] ++ "-") (getBoardDim board)]

-- this generates all possible forward pawn moves
-- it takes a board and the player that will make the next move as arguments
-- and returns a list of all possible boards by moving a PAWN forward
generatePawnMoveForward :: Board -> Player -> [Board]
generatePawnMoveForward board player = 
    let n = getBoardDim board
        target = [player] ++ replicate (n-1) '*' ++ "-"
        replacement = "-" ++ replicate (n-1) '*' ++ [player]
    in
        if player == 'w' 
        then generateNew board 0 (target) (replacement) -- white pawn move downwards
        else generateNew board 0 (replacement) (target) -- black pawn move upwards

-- this generates all possible sideways pawn jumps
-- it takes a board and the player that will make the next move as arguments
-- and returns a list of all possible boards by jumping a PAWN sideways
generatePawnJumpSideways :: Board -> Player -> [Board]
generatePawnJumpSideways board player =
    let opponentPawn = if player == 'b' then 'w' else 'b' -- this sets opponentPawn to w if player == b and vice versa
        opponentFlag = if player == 'b' then 'W' else 'B' -- this sets opponentFlag to W if player == b and vice versa
    in concat [generateNewRowBounded board 0 ([player] ++ [opponentPawn] ++ "-") ("--" ++ [player]) (getBoardDim board), -- captures pawn on its right
               generateNewRowBounded board 0 ("-" ++ [opponentPawn] ++ [player]) ([player] ++ "--") (getBoardDim board), -- captures pawn on its left
               generateNewRowBounded board 0 ([player] ++ [opponentFlag] ++ "-") ("--" ++ [player]) (getBoardDim board), -- captures flag on its right
               generateNewRowBounded board 0 ("-" ++ [opponentFlag] ++ [player]) ([player] ++ "--") (getBoardDim board)] -- captures flag on its left

-- this generates all possible forward pawn jumps
-- it takes a board and the player that will make the next move as arguments
-- and returns a list of all possible boards by jumping a PAWN forward
generatePawnJumpForward :: Board -> Player -> [Board]
generatePawnJumpForward board player =
    let n = getBoardDim board
        -- these are for player == 'w'
        targetPawnW = "w" ++ replicate (n-1) '*' ++ "b" ++ replicate (n-1) '*' ++ "-"
        targetFlagW = "w" ++ replicate (n-1) '*' ++ "B" ++ replicate (n-1) '*' ++ "-"
        replacementW = "-" ++ replicate (n-1) '*' ++ "-" ++ replicate (n-1) '*' ++ "w"

        -- these are for player == 'b'
        targetPawnB = "-" ++ replicate (n-1) '*' ++ "w" ++ replicate (n-1) '*' ++ "b"
        targetFlagB = "-" ++ replicate (n-1) '*' ++ "W" ++ replicate (n-1) '*' ++ "b"
        replacementB = "b" ++ replicate (n-1) '*' ++ "-" ++ replicate (n-1) '*' ++ "-"
    in
        if player == 'w'
        then concat [generateNew board 0 (targetPawnW) (replacementW), -- captures pawn
                    generateNew board 0 (targetFlagW) (replacementW)] -- captures flag
        else concat [generateNew board 0 (targetPawnB) (replacementB), -- captures pawn
                    generateNew board 0 (targetFlagB) (replacementB)] -- captures flag

-- this generates all possible sideway flag moves
-- it takes a board and the player that will make the next move as arguments
-- and returns a list of all possible boards by moving a FLAG sideways
generateFlagMoveSideways :: Board -> Player -> [Board]
generateFlagMoveSideways board player = 
    let flag = if player == 'w' then 'W' else 'B' -- this sets flag to W if player == w and vice versa
    in concat [generateNewRowBounded board 0 ([flag] ++ "-") ("-" ++ [flag]) (getBoardDim board),
               generateNewRowBounded board 0 ("-" ++ [flag]) ([flag] ++ "-") (getBoardDim board)]

-- this generates all possible forward and backward flag moves
-- it takes a board and the player that will make the next move as arguments
-- and returns a list of all possible boards by moving a FLAG forward and backward
generateFlagMoveBackAndForth :: Board -> Player -> [Board]
generateFlagMoveBackAndForth board player = 
    let n = getBoardDim board
        flag = if player == 'w' then 'W' else 'B' -- this sets flag to W if player == w and vice versa
        target = [flag] ++ replicate (n-1) '*' ++ "-"
        replacement = "-" ++ replicate (n-1) '*' ++ [flag]
    -- we don't need if statement here because it covers both forward and backward,
    -- and white forward is essentially black backward.
    in concat [generateNew board 0 (target) (replacement), -- flag moves forward
               generateNew board 0 (replacement) (target)] -- flag moves backward

-- helper functions
-- copied from slides, this generates all possible Boards with targetSegment replaced by replacementSegment
-- it takes a board, the position of where to start checking, the segment that should be replaced, and the
-- segment that will replace the other segment as arguments, and returns all possible boards for each segment
-- being replaced
generateNew :: Board -> Int -> String -> String -> [Board]
generateNew board pos targetSegment replacementSegment
    | pos + (length targetSegment) > length board = []
    | segmentEqual board pos targetSegment =
        (replaceSegment board pos replacementSegment):(generateNew board (pos + 1) targetSegment replacementSegment)
    | otherwise = (generateNew board (pos + 1) targetSegment replacementSegment)

-- helper function that applies sideways moves only within row boundaries
-- it takes a board, the position of where to start checking, the segment that should be replaced, the segment
-- that will replace the other segment, and the dimension of the board as arguments, and returns all possible
-- boards for each segment being replaced within its own row
generateNewRowBounded :: Board -> Int -> String -> String -> Int -> [Board]
generateNewRowBounded board pos targetSegment replacementSegment boardDim
    | pos + (length targetSegment) > length board = []  -- End of board, no more moves
    -- this line is the only change compared to generateNew function. It makes sure that the segment
    -- replacement only happens in the same row instead. The reason this is here is because when I was
    -- testing my program after everything was done, the best move according to computer is to move a
    -- piece from the right-hand side of a row to the left-hand side of the row below it, which is a bug,
    -- so this is now applied to all movement sideways.
    | crossesBoundary pos targetSegment boardDim = generateNewRowBounded board (pos + 1) targetSegment replacementSegment boardDim
    | segmentEqual board pos targetSegment = 
        (replaceSegment board pos replacementSegment):(generateNewRowBounded board (pos + 1) targetSegment replacementSegment boardDim)
    | otherwise = (generateNewRowBounded board (pos + 1) targetSegment replacementSegment boardDim)

-- helper function, it checks if a move would cross a row boundary
-- it takes an integer representing the index of checking, the segment being replaced and the board dimension
-- as arguments, and returns a boolean value that tells if the replacement has crossed the row boundary or not
crossesBoundary :: Int -> String -> Int -> Bool
crossesBoundary pos targetSegment boardDim =
    let segmentLength = length targetSegment
        rowStart = (div pos boardDim) * boardDim
        rowEnd = rowStart + boardDim
    in pos + segmentLength > rowEnd  -- returns True if the segment move to another row

-- copied from slides and edited, this check if a part of the board is equal to a specific segment, 
-- and asterisks in the string can represent any characters (w, b, W, B and -)
-- it takes a board, an position index and a segment being replaced as arguments, and returns a boolean
-- value that indicates whether the segment is the same as the segment on the board starting from position index
segmentEqual :: Board -> Int -> String -> Bool
segmentEqual board pos targetSegment = 
    let segmentToCompare = take (length targetSegment) (drop pos board)
    in equalIgnoringAsterisks targetSegment segmentToCompare

-- this compares the strings with * being any characters
-- it takes two string segments as paramaters and returns a boolean value wheather they are the same,
-- and the * in the strings are being ignored during comparison
equalIgnoringAsterisks :: String -> String -> Bool
equalIgnoringAsterisks targetSegment segmentToCompare
    -- if the strings do not contain asterisks and they are the same, return true
    | targetSegment == segmentToCompare = True
    | head targetSegment == head segmentToCompare = equalIgnoringAsterisks (tail targetSegment) (tail segmentToCompare)
    -- if the character is *, compare the rest
    | head targetSegment == '*' = equalIgnoringAsterisks (tail targetSegment) (tail segmentToCompare)
    | otherwise = False

-- copied from slides, this replace the part of the board with the segment
-- this takes a board, a position index and a new segment as paramaters, and returns
-- the new board where the segment at the board index is replaced by the new segment
replaceSegment :: Board -> Int -> String -> Board
replaceSegment oldList pos segment
    | pos == 0 = replaceSegmentWithAsterisks oldList segment ++ drop (length segment) oldList
    | otherwise = (head oldList): (replaceSegment (tail oldList)(pos - 1) segment)

-- segment might contain *, so we need to replace * with actual characters instead of * onto the board
-- this takes a board and a new segment as arguments and returns a new board contains the new segment
replaceSegmentWithAsterisks :: Board -> String -> Board
replaceSegmentWithAsterisks oldList segment
    -- base case
    | null segment = []
    -- if first char is *, put actual chacter on
    | head segment == '*' = (head oldList):(replaceSegmentWithAsterisks (tail oldList) (tail segment))
    -- otherwise, put first char of segment on
    | otherwise = (head segment):(replaceSegmentWithAsterisks (tail oldList) (tail segment))

-- this function gets the dimension of the board
-- it takes a board as argument and returns the dimension of the board
getBoardDim :: Board -> Int
getBoardDim board = round(sqrt (fromIntegral (length board)))

--------------------------------------------------------------------
---                       board evaluation                       ---
--------------------------------------------------------------------
-- this function evaluates the board, with positive value being favorable for Player,
-- and negative value being not good for Player
-- it takes a board and a player as arguments and returns an integer value of how
-- good the board is for player
evaluateBoard :: Board -> Player -> Int
evaluateBoard board player
    | playerWins board player = 100
    | playerLoses board player = -100
    | otherwise = evaluateBoardValue board player

-- this function checks if one of the three winning conditions is met. Note that the 
-- "can't make a legal move" condition is not here because this is static board evaluation,
-- and since we do not know who will move next, we do not care about that here. It will be
-- checked when the game is played between computer and human.
-- it takes a board and a player as arguments and returns a boolean value indicating 
-- whether player has win or not
playerWins :: Board -> Player -> Bool
playerWins board player = 
    noOpponentFlagLeft board player || noOpponentPawnLeft board player || friendlyFlagPassesAllPawns board player

-- this function checks whether opponent's flag still exisit. If not, it indicates the 
-- player has win the game
-- it takes a board and a player as arguments and returns a boolean value indicating 
-- whether opponent's flag still exisit or not
noOpponentFlagLeft :: Board -> Player -> Bool
noOpponentFlagLeft board player = 
    let opponentFlag = if player == 'b' then 'W' else 'B' -- this sets opponentFlag to W if player is black, and vice versa
    in length (filter (== opponentFlag) board) == 0 -- check if opponent's flag is on the board. If not, this returns True, meaning that the flag has been captured already.

-- this function checks whether any of opponent's pawns still exisit. If not, it 
-- indicates the player has win the game
-- it takes a board and a player as arguments and returns a boolean value indicating 
-- whether opponent's pawns still exisit or not
noOpponentPawnLeft :: Board -> Player -> Bool
noOpponentPawnLeft board player = 
    let opponentPawn = if player == 'b' then 'w' else 'b' -- this sets opponentPawn to w if player is black, and vice versa
    in length (filter (== opponentPawn) board) == 0 -- similar to noOpponentFlagLeft, this returns True if no opponent pawns are left on board

-- this function checks friendly flag has move passed all opponent's pawns
-- it takes a board and a player as arguments and returns a boolean value indicating 
-- whether the friendly flag has move passed all opponent's pawns or not
friendlyFlagPassesAllPawns :: Board -> Player -> Bool
friendlyFlagPassesAllPawns board player = 
    if player == 'w'
    -- if player is white, we check the board backwards. We check a row at a time, and we keep checking until 
    -- 1. the flag is found 2. a opponent's pawn is found. In the 2nd scenario, the function should 
    -- return False. In the first scenario, the function should check if there are any pawns in that
    -- row. If not, return True. If so, return False.
    then friendlyFlagPassesAllPawnsHelper (make2DBoard (reverse board)) 'W' 'b'
    else friendlyFlagPassesAllPawnsHelper (make2DBoard board) 'B' 'w'

-- helper function for friendlyFlagPassesAllPawns. This helper function checks until one of the 2 conditions is met and return a boolean value'
-- it takes a 2D board, the character representing friendly flag, and the character representing opponent's
-- pawns as arguments and returns a boolean value indiciating if friendly  flag has move passed all opponent's pawns or not
friendlyFlagPassesAllPawnsHelper :: Board2D -> Char -> Char -> Bool
friendlyFlagPassesAllPawnsHelper board2D flag opponentPawn 
    | null board2D = False -- if no flag or opponent pawns are found on the board, return False. I don't this will ever happen tho
    -- if flag is found, check for opponent pawns. If no opponent pawns are in the same row, return True, and vice versa
    | elem flag (head board2D) = not (opponentPawn `elem` (head board2D))
    -- if a opponent's pawn is found, return False
    | elem opponentPawn (head board2D) = False
    | otherwise = friendlyFlagPassesAllPawnsHelper (tail board2D) flag opponentPawn

-- this function checks if one of the three losing conditions is met. Note that the 
-- "can't make a legal move" condition is not here because this is static board evaluation,
-- and since we do not know who will move next, we do not care about that here. It will be
-- checked when the game is played between computer and human.
-- it takes a board and a player as arguments and returns a boolean value indicating 
-- whether player has lost or not
playerLoses :: Board -> Player -> Bool
playerLoses board player= 
    noFriendlyFlagLeft board player || noFriendlyPawnLeft board player || opponentFlagPassesAllPawns board player

-- this function checks whether friendly flag still exisit. If not, it indicates the 
-- player has lost the game
-- it takes a board and a player as arguments and returns a boolean value indicating 
-- whether friendly flag still exisit or not
noFriendlyFlagLeft :: Board -> Player -> Bool
noFriendlyFlagLeft board player = 
    let flag = if player == 'w' then 'W' else 'B' -- this sets flag to W if player is white, and vice versa
    in length (filter (== flag) board) == 0 -- check if friendly flag is on the board. If not, this returns True, meaning that the flag has been captured already.

-- this function checks whether any friendly pawns still exisit. If not, it 
-- indicates the player has lost the game
-- it takes a board and a player as arguments and returns a boolean value indicating 
-- whether friendly pawns still exisit or not
noFriendlyPawnLeft :: Board -> Player -> Bool
noFriendlyPawnLeft board player = 
    let pawns = if player == 'w' then 'w' else 'b' -- this sets pawns to w if player is white, and vice versa
    in length (filter (== pawns) board) == 0 -- similar to noFriendlyFlagLeft, this returns True if no friendly pawns are left on board

-- this function checks opponent's flag has move passed all friendly pawns
-- it takes a board and a player as arguments and returns a boolean value indicating 
-- whether the opponent's flag has move passed all friendly pawns or not
opponentFlagPassesAllPawns :: Board -> Player -> Bool
opponentFlagPassesAllPawns board player = 
    if player == 'w'
    -- similar logic to friendlyFlagPassesAllPawns, the only difference is that we are checking the board
    -- in the normal way (not reversed for white) and we check if opponent's flag has passed all our pawns or not.
    then friendlyFlagPassesAllPawnsHelper (make2DBoard board) 'B' 'w'
    else friendlyFlagPassesAllPawnsHelper (make2DBoard (reverse board)) 'W' 'b'

-- this function evaluates how good the board is for player. It is only called if the player is not 
-- winning or losing
-- it takes a board and a player as arguments and returns an integer representing how good
-- the board is in player's perspective
evaluateBoardValue :: Board -> Player -> Int
evaluateBoardValue board player=
    let
        whitePawnCt = length (filter (== 'w') board)
        blackPawnCt = length (filter (== 'b') board)
        -- these two flag counts should always be 1. They are here just in case weird things happens
        whiteFlagCt = length (filter (== 'W') board)
        blackFlagCt = length (filter (== 'B') board)
        -- each flag worth 100 points because you lose without them. They are here in case of bug happens,
        -- so the program can still choose the best move
        whiteScore = whitePawnCt + 100 * whiteFlagCt
        blackScore = blackPawnCt + 100 * blackFlagCt
    in
        -- if player is white, then returns whiteScore-blackScore, and vice versa. If the value is positive,
        -- meaning the board favors player (player is played by computer).
        if player == 'w'
        then whiteScore - blackScore
        else blackScore - whiteScore

----------------------------------------------------------------------
---                            Capture!                            ---
----------------------------------------------------------------------
-- this is the main function to determine the best move using MiniMax
-- it takes a history of boards (a list of boards), a player and a integer
-- representing how many steps ahead the minimax search should look into as
-- arguments and returns the best move for player
capture :: History -> Player -> Int -> Board
capture history player depth =
  let (bestMove, _) = minimax (head history) history player player 0 depth
  in bestMove

-- this minimax algorithm finds the best board after looking ahead "depth" moves
-- it takes a board, the histry of boards, a player as who is minimax analyzing for,
-- a player as who is making the next move, an integer representing how deep the 
-- algorithm is looking at right now, and a integer representing how deep the 
-- algorithm should look into at max. It then returns the best move along with its
-- score as a tuple.
minimax :: Board -> History -> Player -> Player -> Int -> Int -> (Board, Int)
-- to clarify the difference between player and currentplayer, player never changes, but currentplayer
-- changes every depth. This makes sure the board is always evaluated from the player's perspective,
-- and the board gets evaluated correctly each round (because the way I wrote the algorithms, I assume
-- player always move downwards, and the upper part being the base for player. So to make sure the board
-- generates moves correctly, we need to flip the board if player and currentPlayer are different)
minimax board history player currentPlayer depth maxDepth
    -- base case, minimax stops checking if 1. max depth is reached or 2. game is over, and
    -- it will return a tuple of (Board, Int), with int being the current board's evaluation value
    | depth == maxDepth || playerWins board player || playerLoses board player = (board, evaluateBoard board player)
    -- this checks if the currentPlayer can make moves or not. If not, it will return the tuple.
    -- the logic is that if player cannot make next move, it is losing for player, so the value is -100
    -- and vice versa
    | noMoreValidMoves board currentPlayer = if currentPlayer == player then (board, -100) else (board, 100)
    -- recursive case, it generates all posible next move
    | player == currentPlayer = maxValue (nextMoves currentPlayer)
    | player /= currentPlayer = minValue (nextMoves currentPlayer)
    where
        -- this line's syntax is helped by ChatGPT. It basically first generates all possible newBoards after a move,
        -- excluding all boards appeared already in the history, and then add the current board to the history,
        -- and then each new board is paired with a integer value determined by the minimax algorithm. Minimax algorithm
        -- is then recursively called, increasing the depth by 1, eventually hit the base case by either game over or
        -- reach the max depth, then eventually assign the integer value to newBoard, eventually having a full tuple
        -- of (Board, Int)
        nextMoves p = [(newBoard, snd (minimax newBoard (newBoard:history) player (nextPlayer p) (depth + 1) maxDepth)) 
                      | newBoard <- generateNewStates board p, notElem newBoard history]

-- helper functions
-- this switches player to black if white made the move, and vice versa
-- it takes a player as its argument and returns the opposite player
nextPlayer :: Player -> Player
nextPlayer player = if player == 'w' then 'b' else 'w'

-- this is a helper function for minimax. It takes a list of (Board, Int) and return 
-- a (Board, Int) with the greatest Int value
maxValue :: [(Board, Int)] -> (Board, Int)
maxValue boardAndValue
    -- base case, if there is only one (Board, Int), it is the greatest tuple
    | null (tail boardAndValue) = head boardAndValue
    -- this compares the int of each board and select the greater one. It works backwards,
    -- so it basically compares the last element and the second from last element, pick 
    -- the greater one, then compare that one with the third from last, and so on.
    | snd (head boardAndValue) >= snd (maxValue (tail boardAndValue)) = head boardAndValue
    | otherwise = maxValue (tail boardAndValue)

-- this is a helper function for minimax. It takes a list of (Board, Int) and return 
-- a (Board, Int) with the smallest Int value
minValue :: [(Board, Int)] -> (Board, Int)
minValue boardAndValue
    -- base case, if there is only one (Board, Int), it is the smallest tuple
    | null (tail boardAndValue) = head boardAndValue
    -- similar to maxValue, it simply reversed the comparison sign
    | snd (head boardAndValue) <= snd (minValue (tail boardAndValue)) = head boardAndValue
    | otherwise = minValue (tail boardAndValue)

-- this is one of the game-over conditions, when no more valid moves can be made
-- it takes a board and a player as arguments, and returns a boolean value indicating
-- whether any more valid moves can be made or not
noMoreValidMoves :: Board -> Player -> Bool
noMoreValidMoves board player = 
    null (generateNewStates board player) -- this means player can make no more valid moves

--------------------------------------------------------------------------
---                     human-computer interaction                     ---
--------------------------------------------------------------------------
-- ChatGPT helped me here with the do-block's syntax and the if statement's syntax.
-- this function makes human-computer interaction possible. It takes 3 parameters, the history
-- of the boards, the player the human user intend to play as, and the depth the minimax
-- algorithm looks into. If Player == 'w', then the human plays first as white moves first. 
-- If player =='b', then the program will make the move first, then wait for human input.
-- It returns nothing, but rather prints out messages that keeps the game going.
playGame :: History -> Player -> Int -> IO ()
playGame history player depth = 
    do
        let board = head history  -- current board state is the head of history
        -- these two lines prints out the board as 2D array
        putStrLn "" -- prints out an empty line for clarity
        putStrLn "Current board:"
        visualizeBoard board
        
        -- these lines check if the game is over or not. You cannot keep playing
        -- if someone has won already.
        if playerWins board player
            then do
                putStrLn "" -- prints out an empty line for clarity
                putStrLn "You won!"
        else if playerLoses board player
            then do
                putStrLn "" -- prints out an empty line for clarity
                putStrLn "Computer won!"
        else do
            -- human moves first if player is 'w'
            if player == 'w'
                then do
                    -- get human move
                    putStrLn "" -- prints out an empty line for clarity
                    putStrLn "Enter your move. format: ((oldX,oldY),(newX,newY))"
                    input <- getLine
                    -- parsing syntax is helped by ChatGPT
                    let Just humanMove = parseMove input
                    let humanBoard = coordinatesToBoard humanMove board

                    -- prints out the 2D board after human move
                    putStrLn "" -- prints out an empty line for clarity
                    putStrLn "Human's move:"
                    visualizeBoard humanBoard

                    -- update history with human move
                    let newHistory = humanBoard:history

                    -- call capture to make the best computer move
                    let computerMove = capture newHistory 'b' depth

                    -- prints out the 2D board after computer move so the human knows what happened
                    putStrLn "" -- prints out an empty line for clarity
                    putStrLn "Computer's move:"
                    visualizeBoard computerMove

                    -- recursivly calls itself so the game keeps going
                    playGame (computerMove:newHistory) 'w' depth

                else do
                    -- the only difference here is that the computer moves first
                    let computerMove = capture history 'w' depth
                    
                    -- update history with computer move
                    let newHistory = computerMove:history
                    
                    -- prints out the 2D board after computer move so the human knows what happened
                    putStrLn "" -- prints out an empty line for clarity
                    putStrLn "Computer's move:"
                    visualizeBoard computerMove

                    -- get human move
                    putStrLn "" -- prints out an empty line for clarity
                    putStrLn "Enter your move. format: ((oldX,oldY),(newX,newY))"
                    input <- getLine
                    -- parsing syntax is helped by ChatGPT
                    let Just humanMove = parseMove input
                    let humanBoard = coordinatesToBoard humanMove computerMove

                    -- prints out the 2D board after human move
                    putStrLn "" -- prints out an empty line for clarity
                    putStrLn "Human's move:"
                    visualizeBoard humanBoard

                    -- recursivly calls itself so the game keeps going
                    playGame (humanBoard:newHistory) 'b' depth

-- helper functions
-- Note: I tried to use non-pattern matching everywhere else as much as possible for formality,
-- but it is much easier to use pattern matching here so I am using it
-- this function takes two coordinates, replace the element on the first coordinate with the 
-- second coordinate's element on the board
-- it takes a tuple (a tuple of coordinates) of two tuples (coordinates) and a board as arguments,
-- and returns a updated board
coordinatesToBoard :: ((Int, Int), (Int, Int)) -> Board -> Board
coordinatesToBoard ((startX, startY), (endX, endY)) board =
    let
        -- calculate start and end indices to 1D
        startIndex = coordinatesToIndex (startX, startY) (getBoardDim board)
        endIndex = coordinatesToIndex (endX, endY) (getBoardDim board)
        
        -- !! is to access the element in board at startIndex
        piece = board !! startIndex 

        -- updates the board
        updatedBoard = replaceAtIndex startIndex '-' board  -- Empty the start position
        finalBoard = replaceAtIndex endIndex piece updatedBoard  -- Place piece at the end position
    in
        finalBoard

-- it replaces a character at a specific index in a board
-- it takes an index, the new character, and a board as arguments, and 
-- returns the board where board[index] is replaced by the new character
replaceAtIndex :: Int -> Char -> Board -> Board
replaceAtIndex index newChar board =
    take index board ++ [newChar] ++ drop (index + 1) board

-- this converts 2D coordinates to a 1D index in the board
-- the calculation is tweaked a little bit ((boardDim-y) instead of y itself) because the board 
-- is upside down. -1 in the end because haskell index start from 0
-- it takes a tuple (coordinate) and a board dimension as arguments and returns the 
-- index in 1D form
coordinatesToIndex :: (Int, Int) -> Int -> Int
coordinatesToIndex (x, y) boardDim =  boardDim * (boardDim - y) + x - 1

-- Function to convert a string to ((Int, Int), (Int, Int))
-- fully generated by ChatGPT but I understand how it works now
-- it takes a string and try to parse it to (coordinate,coordinate) form
parseMove :: String -> Maybe ((Int, Int), (Int, Int))
parseMove s = readMaybe s